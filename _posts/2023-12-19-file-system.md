---
layout: post
title: 파일 시스템
tags: [운영체제, 파일 시스템]
categories: [운영체제, 파일 시스템]
image:
  path: /assets/img/post/operating-system/file-system.png
  alt: file-system
date: 2023-12-19 00:16 +0900
---

## 파일 시스템

파일 시스템은 **컴퓨터 시스템의 필수 구성 요소로, 하드 드라이브, SSD, USB 드라이브와 같은 저장 장치에 데이터를 저장, 정리, 액세스하는 방법을 제공**한다. 파일 시스템에는 여러 가지 유형과 구조가 있으며, 각각에 대해 알아보자. 😉

### 파일 시스템 유형

- **디스크 파일 시스템**

  - **설명**: **HDD, SSD 등의 데이터 저장 장치에 사용**되는 디스크 파일 시스템은 물리적 저장 매체에 파일과 디렉터리를 저장, 구성, 관리하도록 설계되었다.
  - **구조**: **데이터를 파일과 디렉터리로 구성하는 계층 구조**를 가지고 있으며, 이 구조에는 파일 추적을 위한 마스터 파일 테이블 또는 inode, 구성을 위한 디렉터리 및 실제 파일 저장을 위한 데이터 블록이 포함된다.

    - **장점**: 데이터를 물리적 매체에 직접 저장하기 때문에 빠른 읽기/쓰기 성능을 제공한다.
    - **단점**: 매우 큰 시스템에서는 파일 관리와 백업이 복잡해질 수 있다.
    - **예**: NTFS(Windows), EXT4(Linux), FAT32(크로스 플랫폼).

  - **NTFS(New Technology File System) 구조**
    - **Master File Table**: 크기, 타임스탬프, 권한 및 데이터 콘텐츠를 포함하여 **각 파일 및 디렉터리에 대한 메타데이터를 저장**
    - **Bitmap**: 비트맵의 **각 비트는 볼륨(하드 디스크의 저장 영역)의 클러스터(데이터를 저장하는 가장 작은 공간 단위)에 해당**되며, '1'은 클러스터가 사용됨을 나타내고 '0'은 사용할 수 있음을 나타낸다.
    - **Directory Data**: 파일과 디렉터리의 계층 구조를 추적하는 곳
    - **File**: NTFS 볼륨에 있는 실제 파일을 나타내며, 디스크에 저장되고 파일 시스템에 의해 관리되는 데이터 모음
    - **MFT Mirror**: 마스터 파일 테이블의 부분 복사본이며 MFT가 손상된 경우 복구 목적으로 사용된다.
      ![ntfs](/assets/img/post/operating-system/ntfs.png){: width="800" }
  - **EXT4(Extended File System 4) 구조**
    - **Inode**: EXT4와 같은 **Unix 스타일 파일 시스템의 데이터 구조**로서, 각 inode는 파일, 디렉터리 또는 기호 링크 등의 파일 시스템 개체에 대한 정보를 저장한다.
    - **Extent**: **디스크에 있는 연속적인 물리적 블록**의 범위
    - **Extent-Header**: **익스텐트를 설명하는 구조**로서, 익스텐트의 시작 블록, 익스텐트 내의 블록 수와 같은 정보를 제공
    - **Extent-Index**: 파일 내의 범위를 추적하는 데 사용되는 데이터 구조인 범위 트리의 일부이다. Extent-index는 다른 Extent-Header를 가리키며, 이는 추가 Extent를 설명하거나 추가 Extent-Index를 가리켜 계층적 트리 구조를 생성할 수 있다.
      ![ext4](/assets/img/post/operating-system/ext4.png){: width="800" }

- **네트워크 파일 시스템**
  - **설명**: **네트워크를 통해 파일에 액세스**하기 위한 프로토콜을 제공하여 클라이언트가 마치 로컬인 것처럼 원격 서버의 파일에 액세스하고 관리할 수 있도록 한다.
  - **구조**: NFS는 연결된 서버의 파일 시스템에 의존한다. 네트워크 요청을 해당 서버의 파일 시스템 작업으로 변환한다.
    - **장점**: 네트워크를 통해 원격으로 파일에 액세스할 수 있어 **공동 작업과 자원 공유에 용이**하다.
    - **단점**: 네트워크 지연으로 인해 로컬 파일 시스템보다 접근 속도가 느릴 수 있다.
    - **예**: NFS(네트워크 파일 시스템).

![nfs](/assets/img/post/operating-system/nfs.jpg){: width="800" }

- **데이터베이스 파일 시스템**
  - **설명**: 데이터베이스 개념을 파일 시스템과 통합하여 보다 정교한 데이터 관리를 위해 파일 및 디렉터리를 데이터베이스 항목(테이블, 필드, 관계)으로 처리한다.
  - **구조**: 복잡한 쿼리 및 관계가 가능하며 종종 인덱싱을 위해 B-트리와 같은 데이터 구조를 사용한다.
    - **장점**: **SQL 같은 쿼리 언어를 사용하여 복잡한 검색과 데이터 분석이 가능**하다.
    - **단점**: 전통적인 파일 시스템보다 더 복잡하고 구현이 어려울 수 있다.
    - **예**: Oracle, MySQL.
- **분산 파일 시스템**
  - **설명**: **여러 서버에 걸쳐 데이터를 저장하고 관리**하도록 설계되어 고가용성과 확장성을 제공한다.
  - **구조**: 파일은 일관성과 내결함성을 보장하기 위한 데이터 복제 및 동기화 메커니즘을 통해 여러 노드에 분산된다.
    - **장점**: 데이터 복제를 통해 **하드웨어 장애가 발생해도 데이터 손실의 위험을 줄일 수 있다**.
    - **단점**: 데이터의 일관성을 유지하기 위한 **동기화 작업이 추가적인 시스템 오버헤드를 발생**시킬 수 있다.
    - **예**: HDFS(Hadoop 분산 파일 시스템).

![hdfs](/assets/img/post/operating-system/hdfs.png){: width="600" }

### 파일 관리 기법

파일 관리 기법은 컴퓨터 시스템에서 **파일을 효율적으로 저장, 검색, 수정 및 관리하는 방법**을 말한다. <br>
주요 파일 관리 기법에 대해 알아보자. 😉

#### 파일 시스템 구조

- **계층적 구조 (Hierarchical Structure)**
  - 대부분의 파일 시스템은 **계층적인 디렉터리 구조를 사용**한다. 폴더와 서브폴더를 통해 파일을 조직화한다.
  - NTFS, ext4와 같은 파일 시스템에서 사용되며 대부분 그래픽 사용자 인터페이스에서 쉽게 시각화된다.​​​​

![hierarchy-file](/assets/img/post/operating-system/hierarchy-file.png){: width="500" }

- **플랫 구조 (Flat Structure)**

  - 계층적 파일 시스템과 달리 플랫 파일 시스템은 파일을 구성하기 위해 디렉터리를 사용하지 않는다. 대신 **모든 파일이 단일 디렉터리에 저장**된다.
  - 어떤 파일도 다른 파일의 "하위"가 아니므로 구조가 단순화되지만 많은 수의 파일을 처리할 때 파일을 구성하고 찾는 것이 다소 어려워진다.

- **인덱스 구조 (Indexed Structure)**
  - **파일은 디스크의 파일 위치에 대한 정보를 보유하는 인덱스와 연결**된다.
  - 파일에 액세스해야 할 때 시스템은 전체 디스크를 검색할 필요 없이 신속하게 해당 파일을 찾기 위해 해당 인덱스를 조회한다.

![index-file](/assets/img/post/operating-system/index-file.png){: width="600" }

#### 파일 할당 방법

- **연속 할당 (Contiguous Allocation)**
  - 파일의 모든 데이터가 **디스크 상에서 연속적인 공간에 저장**된다.
  - 장점
    - 블록이 연속되어 있기 때문에 **읽기/쓰기 헤드가 덜 움직여야 하므로 더 빠른 액세스**가 가능합니다.
    - 시작 블록과 길이만 있으면 파일을 찾을 수 있어 구현이 간단합니다.
  - 단점
    - 시간이 지남에 따라 파일이 삭제되고 생성되면서 **외부단편화(남아있는 메모리의 크기가 충분하지만, 연속적이지 않은 공간에 존재하여 실행하지 못하는 현상)가 발생하여** 새 파일을 위한 연속 공간이 부족해질 수 있다.
    - 파일이 처음에 할당된 공간보다 커지는 경우에도 확장된 크기를 수용할 수 있는 연속된 공간이 없을 수 있으므로 유연성이 부족하다.​​​​

![contiguous-allocation](/assets/img/post/operating-system/contiguous-allocation.png){: width="350" }

- **연결 리스트 할당 (Linked List Allocation)**
  - 파일의 각 부분이 **디스크의 다양한 위치에 저장**되며, 각 부분은 다음 부분의 위치를 가리킨다.
  - 장점
    - 어떤 블록이라도 파일에 추가할 수 있으므로 외부 조각화가 발생하지 않는다.
    - **순차 접근에 적합하며, 생성 후 크기가 늘어나는 파일을 수용**할 수 있다.
  - 단점
    - 블록 n에 접근하려면 파일 시스템이 n-1개의 블록을 통과해야 하므로 직접 접근이나 랜덤 접근에는 효율적이지 않다.
    - 각 블록 내 포인터를 위한 **추가 저장 공간이 필요**하며, 단일 블록을 잃으면 전체 파일이 손실될 수 있다.

![linked-list-allocation](/assets/img/post/operating-system/linked-list-allocation.png){: width="350" }

- **인덱스 할당 (Indexed Allocation)**
  - 파일의 모든 블록에 대한 포인터를 포함하는 인덱스 블록이 생성되며, 디렉토리 항목에는 인덱스 블록에 대한 포인터가 포함되어 있으며 **인덱스 블록은 실제 파일 블록을 가리킨다**.
  - 장점
    - 인덱스를 통해 모든 블록에 직접 접근이 가능하다.
    - 블록은 디스크의 어느 곳에나 있을 수 있으므로 외부 단편화를 방지한다.
  - 단점
    - 인덱스 블록이 손상되면 파일 전체가 손실될 수 있다.

![indexed-allocation](/assets/img/post/operating-system/indexed-allocation.png){: width="400" }
