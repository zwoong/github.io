---
layout: post
title: 프로세스 관리
tags: [운영체제, 프로세스 관리]
categories: [운영체제, 프로세스 관리]
date: 2023-12-16 00:02 +0900
---

## 프로세스

프로세스는 본질적으로 **실행되는 컴퓨터 프로그램의 인스턴스**다. 컴퓨터에서 **프로그램을 실행하면 운영 체제에서 해당 프로그램에 대한 프로세스를 생성**하고, 프로세스는 메모리, CPU 시간, 입출력(I/O) 등 실행에 필요한 리소스를 프로그램에 제공한다.

### 프로세스 구조

![process-structure](/assets/img/post/operating-system/process-structure.png){: width="600" }

- **code**
  - 프로그램의 **컴파일된 바이너리 코드가 포함**되어 있다.
  - 일반적으로 프로그램이 실수로 명령을 수정하는 것을 방지하기 위해 읽기 전용이다.
- **data**
  - 프로그램에서 사용하는 **전역 변수와 정적 변수**가 들어 있다.
- **heap**
  - 힙은 **동적 메모리 할당에 사용**된다.
  - 변수는 런타임 중에 생성, 크기 조정 및 삭제될 수 있다. 즉, 프로그램이 실행되는 동안 힙이 늘어나고 줄어들 수 있다.
- **stack**
  - 함수 매개변수, 반환 주소, 지역 변수와 같은 **임시 데이터가 포함**된다.
  - **후입선출(LIFO) 방식**으로 운영된다.
  - 스택의 크기는 함수 호출 및 반환에 따라 동적으로 변경된다.

> 높은 메모리 주소와 낮은 메모리 주소는 무엇을 의미할까? 🧐

### 메모리의 높음과 낮음

- **"높음"과 "낮음"이라는 용어는 실제로 상대적**이며 메모리 주소의 숫자 범위를 나타낸다.
- 스택은 일반적으로 높은 메모리 주소에서 낮은 메모리 주소로 증가하며, 힙은 일반적으로 낮은 메모리 주소에서 높은 메모리 주소로 증가한다. **(둘 사이에 "간격" 또는 매핑되지 않은 영역을 제공하여 충돌을 방지)**
- 적절한 메모리 관리는 스택과 힙 모두에 충분한 주소 공간을 확보하여 중복 및 잠재적인 데이터 손상을 방지한다.

### 프로세스 제어 블록(PCB - Process Control Block)

프로세스 제어 블록(PCB)은 **프로세스에 대한 정보가 포함된 운영 체제(OS)의 중요한 데이터 구조**이다. <br>
OS에서 프로세스 실행을 관리하고 [프로세스 간 컨텍스트 전환](https://ko.wikipedia.org/wiki/%EB%AC%B8%EB%A7%A5_%EA%B5%90%ED%99%98)을 수행하는 데 사용된다. **PCB가 없으면 OS는 프로세스 상태를 보존할 수 없어 실행이 부정확하거나 불완전**해진다. 이는 정보 손실 없이 프로세스를 중단했다가 나중에 재개할 수 있도록 하여 원활한 운영과 효율적인 리소스 사용을 가능하게 한다.

#### PCB의 주요 내용

- **PID(프로세스 식별자)**: 프로세스를 참조하기 위해 OS 및 기타 프로세스에서 사용하는 프로세스의 고유 식별자
- **프로세스 상태**: 프로세스의 현재 상태(예: 신규, 준비, 실행 중, 대기 중, 종료됨)를 저장
- **프로그램 카운터**: 이 프로세스에 대해 실행될 다음 명령어의 주소를 저장
- **CPU 레지스터**: 프로세스 레지스터의 현재 값으로, 컨텍스트 전환이 발생하면 프로세스가 올바르게 실행을 재개할 수 있도록 이러한 값이 저장된다.
- **CPU 스케줄링 정보**: 여기에는 프로세스 우선순위, 스케줄링 대기열에 대한 포인터 및 기타 스케줄링 매개변수와 같은 CPU 스케줄러에 대한 정보가 저장된다.

### 프로세스 상태 전이도

![process-state-transitions](/assets/img/post/operating-system/process-state-transitions.png){: width="600" }

- **New**: 프로세스가 생성되는 상태
- **Ready**: 프로세스가 생성된 후 "준비" 상태로 전환되어 프로세서에 할당되기를 기다리고 있다.
- **Running**: 프로세스 스케줄러가 준비된 프로세스를 디스패치 하면 "실행 중" 상태로 전환된다.
- **Waiting**: 프로세스가 I/O 작업이 완료되거나 일부 이벤트가 발생할 때까지 기다려야 하는 경우 "대기" 상태로 전환된다.
- **Terminated**: 프로세스 실행이 완료되거나 중지된 후 "종료됨" 상태로 이동한 다음 시스템에서 제거된다.

### 스케줄링 알고리즘

**언제 어떤 프로세스에 CPU를 할당할지, 시간을 얼마나 할당할지에 대한 알고리즘**을 스케줄링 알고리즘이라고 한다.

- **First-Come, First-Served (FCFS)**
  - 원칙: 프로세스는 도착 시간에 따라 예약되며, **도착하는 첫 번째 프로세스가 가장 먼저 실행**된다.
  - 장점: 간단하고 공정하다.
  - 단점: 긴 프로세스가 짧은 프로세스보다 먼저 도착하는 경우 평균 대기 시간이 길어진다.

![fcfs](/assets/img/post/operating-system/fcfs.png){: width="600" }

- **Shortest Job First (최단 작업 우선)**
  - 원리: **실행 시간이 가장 짧은 프로세스가 다음으로 실행**된다.
  - 장점: 실행 시간이 짧은 프로세스를 먼저 처리하기 때문에 평균 대기 시간을 최소화할 수 있다.
  - 단점: 실행 시간이 긴 프로세스의 경우 비교적 실행시간이 짧은 프로세스에 우선순위가 밀려 **오랫동안 CPU를 할당받지 못해 [기아 상태](https://ko.wikipedia.org/wiki/%EA%B8%B0%EC%95%84_%EC%83%81%ED%83%9C)**으로 이어질 수 있다.

![sjf](/assets/img/post/operating-system/sjf.png){: width="800" }

- **Priority Scheduling**
  - 원칙: 프로세스에 우선순위가 할당되고 **우선순위가 가장 높은 프로세스가 먼저 실행**된다.
  - 장점: 중요한 프로세스가 더 많은 CPU 시간과 높은 우선순위를 받도록 하는 데 사용할 수 있다.
  - 단점: 우선순위가 높은 프로세스가 계속 추가되면 우선순위가 낮은 프로세스는 기아 상태로 이어질 수 있다.

![priority](/assets/img/post/operating-system/priority.webp){: width="600" }

- **Round Robin (RR)**
  - 원리: 프로세스가 도착한 순서대로 프로세스를 실행하지만, 정해진 시간에 의해 실행을 제한하며, **시간 할당량을 프로세스에 주고 할당된 시간 안에 완료되지 못한 프로세스는 준비 큐의 맨 뒤에 배치**되도록 한다.
  - 장점: 공정하고 단순하며, 모든 프로세스는 CPU를 동일하게 공유한다.
  - 단점: 성능은 시간 할당량의 길이에 따라 크게 영향을 받을 수 있다. 너무 짧은 시간을 할당할 경우 컨텍스트 전환이 자주 발생하여 오버헤드가 높아진다. 너무 긴 시간을 할당하면 프로세스에 평균 대기 시간이 증가한다.

![round-robin](/assets/img/post/operating-system/round-robin.jpg){: width="500" .w-60 .left }

<br>

- **ARRIVAL TIME** : 각 프로세스가 도착하여 실행될 준비가 된 시간
- **BURST TIME** : 각 프로세스가 실행을 완료하는 데 필요한 총 CPU 시간 <br>
  - Total: 총 버스트 시간을 표기
  - Remaining: 남은 버스트 시간을 표기

<br><br><br><br><br>

- **Multilevel Queue Scheduling(다단계 대기열 스케줄링)**
  - 원리: **각각 고유한 예약 알고리즘을 사용하는 여러 개의 별도 대기열로 나눈다**. 프로세스는 우선순위, 메모리 요구 사항 또는 프로세스 유형과 같은 프로세스 속성에 따라 알맞은 대기열에 할당된다.
  - 장점: 프로세스가 잘 분류되면 효율적일 수 있다.
  - 단점: 프로세스가 대기열 간에 이동하지 않아 유연성이 떨어지고 비효율성이 발생할 수 있다.

![multilevel-queue](/assets/img/post/operating-system/multilevel-queue.png){: width="400" }

- **Multilevel Feedback Queue Scheduling(다단계 피드백 큐 스케줄링)**
  - 원리: **Multilevel Queue Scheduling과 유사하지만 프로세스는 동작 및 기간에 따라 대기열 간에 이동을 할 수 있다**. 이 전략을 사용하면 프로세스의 우선순위를 동적으로 변경할 수 있다.
  - 장점: 유연성이 뛰어나며, 기아를 방지하고 현재 동작에 따라 프로세스의 우선순위를 지정할 수 있다.
  - 단점: 구현이 복잡하고 유지 관리에 계산 비용이 많이 들 수 있다.

![multilevel-feedback-queue](/assets/img/post/operating-system/multilevel-feedback-queue.png){: width="400" }
